{"0": {
    "doc": "Álgebra Lineal",
    "title": "Álgebra Lineal",
    "content": "# Álgebra Lineal Finalmente se resuelve el problema lineal mediante numpy.linalg.solve ",
    "url": "/docs/Elementos%20Finitos/AlgebraLineal/",
    "relUrl": "/docs/Elementos%20Finitos/AlgebraLineal/"
  },"1": {
    "doc": "Condiciones de Borde",
    "title": "Condiciones de Borde",
    "content": "# Condiciones de borde El código implementa condiciones de borde de Dirichlet homogéneas, marcando los nodos de borde y añadiendo la ecuación a la matriz global. ",
    "url": "/docs/Elementos%20Finitos/CondicionesdeBorde/",
    "relUrl": "/docs/Elementos%20Finitos/CondicionesdeBorde/"
  },"2": {
    "doc": "Diferencias Finitas",
    "title": "Diferencias Finitas",
    "content": "# Diferencias Finitas ## Matrices de diferencias ## Iteraciones temporales ## Visualizar una animación ",
    "url": "/docs/diferencias-finitas",
    "relUrl": "/docs/diferencias-finitas"
  },"3": {
    "doc": "Elementos Finitos",
    "title": "Elementos Finitos",
    "content": "# Elementos Finitos Para facilitar la implementación de códigos de Elementos Finitos escribimos estas rutinas que hacen distintos cálculos en elementos de referencia, luego cambian de variables, y se añaden tratamientos, etc. {: .fs-6 .fw-300 } ",
    "url": "/docs/elementos-finitos",
    "relUrl": "/docs/elementos-finitos"
  },"4": {
    "doc": "Formas Débiles",
    "title": "Formas Débiles",
    "content": "# Formas débiles El código calcula integrales locales de la forma: $$ \\int_T \\nabla \\phi_i \\nabla \\phi_j dx $$ y luego las ensambla en una matriz global. ",
    "url": "/docs/Elementos%20Finitos/FormasDebiles/",
    "relUrl": "/docs/Elementos%20Finitos/FormasDebiles/"
  },"5": {
    "doc": "Interpolación y cuadratura",
    "title": "Interpolación y cuadratura",
    "content": "# Interpolación y cuadratura {: .no_toc } ## Índice {: .no_toc .text-delta } 1. TOC {:toc} # Interpolación Tenemos definidas las siguientes bases de Lagrange: * En un triángulo * Elementos Lineales * En un rectángulo * Por ahora nada # Cuadratura Junto con las cuadraturas: - Exactas para $$\\mathcal{P}_2$$ en un triángulo ",
    "url": "/docs/Elementos%20Finitos/Interpolacion/",
    "relUrl": "/docs/Elementos%20Finitos/Interpolacion/"
  },"6": {
    "doc": "Malladores",
    "title": "Malladores",
    "content": "# Malladores Lo primero en un código de Elementos Finitos es definir una geometría discreta (una malla). El código puede hacer lo siguiente: - Definir una nube de puntos y mallar mediante scipy.spatial.Delaunay - Definir una geometría y construir una malla mediante dmesh. - Encontrar los nodos de borde de una triangulación. ",
    "url": "/docs/Elementos%20Finitos/Malladores/",
    "relUrl": "/docs/Elementos%20Finitos/Malladores/"
  },"7": {
    "doc": "Home",
    "title": "Home",
    "content": "# Métodos de Diferencias Finitas y Elementos Finitos {: .fs-9 } $$ \\left\\lbrace \\begin{array}{cc} \\Delta u = f & x\\in\\Omega \\\\ u = 0 & x\\in\\partial\\Omega \\end{array} \\right. $$ Códigos elementales para la resolución de Ecuaciones en Derivadas Parciales, escritos con fines educativos, como parte de un curso de Análisis Numérico de la Facultad de Ciencias Exactas y Naturales, Universidad de Buenos Aires. {: .fs-6 .fw-300 } [Comenzar](#comenzar){: .btn .btn-primary .fs-5 .mb-4 .mb-md-0 .mr-2 } [Ver en GitHub](https://github.com/pmarsceill/just-the-docs){: .btn .fs-5 .mb-4 .mb-md-0 } --- ## Comenzar Para contribuir código al proyecto, es necesario tener una cuenta de GitHub. Luego, ir a la página del proyecto y hacer click en \"Fork\". Entonces tendremos una copia personal del repositorio bajo nuestro nombre en el servidor de Github. Para descargarlo, el comando que necesitamos es {% highlight console %} git clone https://github.com/your.github.username/MateUBA_PDE.git {% endhighlight %} (modificando your.github.username por el nombre de usuario que hayamos registrado). Después de trabajar localmente con el código, cuando querramos subir una copia al servidor, hacer {% highlight console %} git add file1.py file2.py {% endhighlight %} donde file1.py file2.py son los archivos que hemos modificado o añadido. Alternativamente, se puede hacer {% highlight console %} git add --all {% endhighlight %} para añadir todos los archivos del directorio de trabajo (usar esto con cuidado). Este comando (add) añade los archivos a la lista de archivos del repositorio. Para prepararnos para subir la contribución, hacer {% highlight console %} git commit -m \"mensaje\" {% endhighlight %} donde \"mensaje\" incluye un texto con la descripción de los cambios. Finalmente, con {% highlight console %} git push {% endhighlight %} se hace la transferencia de datos hacia el servidor de Github. Ahora bien, si queremos que nuestros cambios sean incorporados a la versión oficial del proyecto, hay que ir a la página de Github del mismo y pedir un \"pull request\". El administrador así podrá revisar nuestros cambios y decidir si los acepta. ",
    "url": "/",
    "relUrl": "/"
  }
}
